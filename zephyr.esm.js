 /** Zephyr * @version 1.0.1 esm * @see https://github.com/Serrin/ * @license MIT */
"use strict";
/** Polyfills **/
if(!("MIN_SAFE_INTEGER" in Number)){Number.MIN_SAFE_INTEGER=-9007199254740991;}
if(!("MAX_SAFE_INTEGER" in Number)){Number.MAX_SAFE_INTEGER=9007199254740991;}
Number.isInteger=Number.isInteger||function(v){return typeof v==="number"&&isFinite(v)&&Math.floor(v)===v;};
if(!Object.is){Object.is=((x,y)=>((x===y)?(x!==0||1/x===1/y):(x!==x&&y!==y)));}
Object.hasOwn=Object.hasOwn||((O,P)=>Object.prototype.hasOwnProperty.call(O,P));
/** API **/
function Completion(completionRecord){if(completionRecord!=null&&typeof completionRecord==="object"){let crKeys=Object.keys(completionRecord);if(crKeys.length===3&&crKeys.includes("[[Type]]")&&crKeys.includes("[[Value]]")&&crKeys.includes("[[Target]]")){return completionRecord;}}throw new TypeError( "Completion(); TypeError: completionRecord is not a Completion Record");}
const Type=(O)=>((O===null)?"null":(typeof O));
const StringIndexOf=(string,searchValue,fromIndex)=>string.indexOf(searchValue,fromIndex);
const StringLastIndexOf=(string,searchValue,fromIndex)=>string.lastIndexOf(searchValue,fromIndex);
const NormalCompletion=(v)=>({"[[Type]]":"NORMAL","[[Value]]":v,"[[Target]]":undefined});
const ThrowCompletion=(v)=>({"[[Type]]":"THROW","[[Value]]":v,"[[Target]]":undefined});
const ReturnCompletion=(v)=>({"[[Type]]":"RETURN","[[Value]]":v,"[[Target]]":undefined});
function UpdateEmpty(completionRecord,value){function Completion(completionRecord){if(completionRecord!=null&&typeof completionRecord==="object"){let crKeys=Object.keys(completionRecord);if(crKeys.length===3&&crKeys.includes("[[Type]]")&&crKeys.includes("[[Value]]")&&crKeys.includes("[[Target]]")){return completionRecord;}}throw new TypeError("Completion(); TypeError: completionRecord is not a Completion Record");}Completion(completionRecord);if(completionRecord["[[Type]]"]==="RETURN"||completionRecord["[[Type]]"]==="THROW"){if(completionRecord["[[Value]]"]!==undefined){return completionRecord;}return{"[[Type]]":completionRecord["[[Type]]"],"[[Value]]":value,"[[Target]]":completionRecord["[[Target]]"]};}}
/* IsAccessorDescriptor */
/* IsDataDescriptor */
/* IsGenericDescriptor */
/* FromPropertyDescriptor */
/* ToPropertyDescriptor */
/* CompletePropertyDescriptor */
function ToPrimitive(O,hint="default"){const _apply=Function.prototype.call.bind(Function.prototype.apply);const _isPrimitive=(v)=>((typeof v!=="object"&&typeof v!=="function")||v===null);if(_isPrimitive(O)){return O;}let method=O[Symbol.toPrimitive];if(method !=null){let r=_apply(method,O,[]);if(_isPrimitive(r)){return r;}}else{for(let item of(hint==="string"?["toString","valueOf"]:["valueOf","toString"])){method=O[item];if(typeof method==="function"){let r=_apply(method,O,[]);if(_isPrimitive(r)){return r;}}}}throw new TypeError("ToPrimitive(); Error: Cannot convert object to primitive value");}
function OrdinaryToPrimitive(O,hint){if(typeof hint==="string"){var methodNames=["toString","valueOf"];}else{var methodNames=["valueOf","toString"];}for(let element of methodNames){let method=O[element];if(typeof method==="function"){let result=Function.prototype.call.call(method,O);if(typeof result!=="object"){return result;}}}throw new TypeError();}
const ToBoolean=(v)=>Boolean(v);
function ToNumeric(v){var type=((v===null)?"null":(typeof v));if(type==="bigint"||type==="number"){return v;}if(type==="symbol"){throw new TypeError("Symbol: "+v);}return +v;}
const ToNumber=(v)=>+v;
const StringToNumber=(v)=>+v;
const ToIntegerOrInfinity=(v)=>((v =Math.trunc(+v))!==v||v===0)?0:v;
const ToInt32=(v)=>((v=Math.min(Math.max(-2147483648,Math.trunc(+v)),2147483647))===v)?v:0;
const ToUint32=(v)=>((v=Math.min(Math.max(0,Math.trunc(+v)),4294967295))===v)?v:0;
const ToInt16=(v)=>((v=Math.min(Math.max(-32768,Math.trunc(+v)),32767))===v)?v:0;
const ToUint16=(v)=>((v=Math.min(Math.max(0,Math.trunc(+v)),65535))===v)?v:0;
const ToInt8=(v)=>((v=Math.min(Math.max(-128,Math.trunc(+v)),127))===v)?v:0;
const ToUint8=(v)=>((v=Math.min(Math.max(0,Math.trunc(+v)),255))===v)?v:0;
const ToUint8Clamp=(v)=>((v=Math.min(Math.max(0,Math.trunc(+v)),255))===v)?v:0;
const ToBigInt=(v)=>BigInt(v);
const StringToBigInt=(v)=>BigInt(v);
const ToBigInt64=(v)=>BigInt(v);
const ToBigUint64=(v)=>BigInt(typeof v==="bigint"?(v>Math.pow(2,64)-1?Math.pow(2,64)-1:v<0?0:v):((v=Math.min(Math.max(0,Math.trunc(Number(v))),Math.pow(2,64)-1))===v)?v:0);
const ToString=(v)=>String(v);
function ToObject(O){if(O==null){throw new TypeError("ToObject(); Error: "+O);}if(["object","function"].includes(typeof O)){return O;}return Object(O);}
const ToPropertyKey=(v)=>(typeof v==="symbol"? v:String(v));
function ToLength(v){v=((v=Math.trunc(+v))!==v||v===0)?0:v;return Math.min(Math.max(v,0),Math.pow(2,53)-1);}
function CanonicalNumericIndexString(v){if(typeof v==="number"&&1/v===-Infinity){return -0;}let n=+v;if(String(n)===v){return n;}}
function RequireObjectCoercible(v){if(v==null){throw new TypeError(Object.prototype.toString.call(v)+ " is not coercible to Object.");}return v;}
function ToIndex(v){v=((v=Math.trunc(+v))!==v||v===0)?0:v;if(v<0||v>(Math.pow(2,53)-1)){throw new RangeError("ToIndex(); RangeError: "+v);}return v;}
const IsArray=Array.isArray||function(O){return Object.prototype.toString.call(O)==="[object Array]";};
const IsCallable=(v)=>((v!=null&&["object","function"].includes(typeof v))?(typeof v.call==="function"):false);
const IsConstructor=(v)=>(typeof v==="function"&&typeof v.prototype==="object");
const IsExtensible=(O)=>Object.isExtensible(O);
const IsIntegralNumber=Number.isInteger||function(v){return typeof v==="number"&&isFinite(v)&&Math.floor(v)===v;};
const IsRegExp=(v)=>(v instanceof RegExp);
const IsPropertyKey=(v)=>(typeof v==="string"||typeof v==="symbol");
const IsStringWellFormedUnicode=(string)=>string.isWellFormed();
const SameType=(x,y)=>(x==null&&x===y)?true:(typeof x===typeof y);
const SameValue=Object.is||((x,y)=>((x===y)?(x!==0||1/x===1/y):(x!==x&&y!==y)));
const SameValueZero=(x,y)=>(x===y||(x!==x&&y!==y));
function SameValueNonNumber(x,y){if(typeof x==="number"||typeof y==="number"){throw new TypeError("SameValueNonNumber(); TypeError: x and y both have to be non number");}return (x===y);}
const IsLessThan=(x,y,leftFirst=true)=>(leftFirst?(x<y):(x>y));
const IsLooselyEqual=(x,y)=>(x==y);
const IsStrictlyEqual=(x,y)=>(x===y);
function MakeBasicObject(internalSlotsList){if(internalSlotsList==null){internalSlotsList={};}let res={};if(internalSlotsList !=null&&typeof internalSlotsList==="object"){for(let key of Object.keys(internalSlotsList)){Object.defineProperty(res,key,{configurable:true,enumerable:false,writable:true,value:internalSlotsList[key]});}}return res;}
const Get=(O,P)=>O[P];
function GetV(O,P){if(O==null){throw TypeError();}return Object(O)[P];}
function Set(O,P,V,Throw=false){O[P]=V;if(O[P]!==V&&Throw){throw new TypeError("(); Error: "+O+"["+P+"]");}}
const CreateDataProperty=(O,P,V)=>Object.defineProperty(O,P,{value:V,writable:true,enumerable:true,configurable:true});
function CreateDataPropertyOrThrow(O,P,V){Object.defineProperty(O,P,{writable:true,enumerable:true,configurable:true,value:V});if(O[P]!==V){throw new Error("CreateDataPropertyOrThrow(); Error: "+O+"["+P+"]");}return O;}
function CreateNonEnumerableDataPropertyOrThrow(O,P,V){if(O !=null&&typeof O==="object"){Object.defineProperty(O,P,{writable:true,enumerable:false,configurable:true,value:V});}if(O[P]!==V){throw new TypeError("CreateNonEnumerableDataPropertyOrThrow();error");}}
function DefinePropertyOrThrow(O,P,desc){Object.defineProperty(O,P,desc);if(O[P]!==desc.value){throw new Error();}}
function DeletePropertyOrThrow(O,P){delete O[P];if(P in O){throw new Error("Object Property delete error: "+O+"["+P+"]");}}
function GetMethod(O,P){let func=O[P];if(func==null){return undefined;}if(typeof func!=="function"){throw new TypeError("Method not callable: "+P);}return func;}
const HasProperty=(O,P)=>(P in O);
const HasOwnProperty=(O,P)=>Object.prototype.hasOwnProperty.call(O,P);
function Call(F,V,argumentsList=[]){if(!Array.isArray(argumentsList)){throw new TypeError("argumentsList should be an array: ",argumentsList);}return Function.prototype.apply.call(F,V,argumentsList);}
const Construct=(F,argumentsList,newTarget)=>Reflect.construct(F,argumentsList||[],newTarget||F);
function SetIntegrityLevel(O,level){if(level==="SEALED"){Object.seal(O);return Object.isSealed(O);}if(level==="FROZEN"){Object.freeze(O);return Object.isFrozen(O);}}
function TestIntegrityLevel(O,level){if(Object.isExtensible(O)){return false;}if(level==="SEALED"){return Object.isSealed(O);}if(level==="FROZEN"){return Object.isFrozen(O);}}
const CreateArrayFromList=(...A)=>A;
function LengthOfArrayLike(O){let v=Math.trunc(+O.length);v=((v!==v||v===0)?0:v);return Math.min(Math.max(v,0),Math.pow(2,53)-1);}
function CreateListFromArrayLike(O,validElementTypes){const Type=(v)=>((v===null)?"null":(typeof v));function ToLength(argument){let v=+argument;if(1/v===Infinity||1/v===-Infinity||v!==v){v=0;}let len=((v===Infinity||v===-Infinity)?v:Math.trunc(v));if(len<0){return 0;}return Math.min(len,Math.pow(2,53)-1);}if(validElementTypes==null){validElementTypes=["undefined","null","boolean","string","symbol","number","bigint","object"];}if(Type(O)!=="object"){throw new TypeError(O+" is not an object");}let len=ToLength(O.length),list=[],i=0;while(i<len){let next=O[String(i)];if(validElementTypes.indexOf(Type(next))< 0){throw new TypeError();}list.push(next);i++;}return list;}
function Invoke(V,P,argumentsList=[]){function Call(F,V,argumentsList=[]){if(!Array.isArray(argumentsList)){throw new TypeError("argumentsList should be an array: ",argumentsList);}return Function.prototype.apply.call(F,V,argumentsList);}return Call(Object(V[P]),V,argumentsList);}
function OrdinaryHasInstance(C,O){const Type=(O)=>(O===null?"null":typeof O);if(Type(C)!=="function"){return false;}if(Type(O)!=="object"){return false;}if(Type(C.prototype)!=="object"){throw new TypeError("OrdinaryHasInstance(); TypeError: C.prototype is not an object");}return O instanceof C;}
function SpeciesConstructor(O,defaultConstructor){let C=O.constructor;if(C===undefined){return defaultConstructor;}if(!(["object","function"].includes((C===null)?"null":(typeof C)))){throw new TypeError("O.constructor is not an Object");}let S=(typeof self.Symbol==="function"&&typeof self.Symbol.species==="symbol")?C [self.Symbol.species]:undefined;if(S==null){return defaultConstructor;}if(typeof S==="function"&&typeof S.prototype==="object"){return S;}throw new TypeError("No constructor found");}
function EnumerableOwnProperties(O,kind){switch(kind){case "KEY":return Object.keys(O);case "VALUE":return Object.values(O);case "KEY+VALUE":return Object.entries(O);default:return [];}}
/* GetFunctionRealm */
function CopyDataProperties(target,source,excludedItems){function ToObject(O){if(O==null){throw new TypeError("ToObject(); Error: "+O);}if(["object","function"].includes(typeof O)){return O;}return Object(O);}if(source==null){return undefined;}let from=ToObject(source);let keys=Object.keys(from).filter((v)=>!(excludedItems.includes(v)));for(let key of keys){target[key]=source[key];}}
/* PrivateElementFind */
/* PrivateFieldAdd */
/* PrivateMethodOrAccessorAdd */
/* HostEnsureCanAddPrivateElement */
/* PrivateGet */
/* PrivateSet */
/* DefineField */
/* InitializeInstanceElements */
function AddValueToKeyedGroup(groups,key,value){let count=0,keyPos=0;groups.forEach(function(record,index){if(Object.is(record["[[Key]]"],key)){count++;keyPos=index;}});if(count>1){throw new Error("AddValueToKeyedGroup(); Error: there are more records with the key" );}if(!count){groups.push({"[[Key]]":key,"[[Elements]]":[value]});}else{groups[keyPos]["[[Elements]]"].push(value)}}
function GroupBy(items,callback,keyCoercion){const Type=(O)=>(O===null?"null":typeof O);function AddValueToKeyedGroup(groups,key,value){let count=0,keyPos=0;groups.forEach(function(record,index){if(Object.is(record["[[Key]]"],key)){count++;keyPos=index;}});if(count>1){throw new Error("AddValueToKeyedGroup(); Error: there are more records with the key");}if(!count){groups.push({"[[Key]]":key,"[[Elements]]":[value]});}else{groups[keyPos]["[[Elements]]"].push(value)}}if(Type(items)!=="object"){throw new TypeError("GroupBy(); TypeError: items is not an object");}if(Type(callback)!=="function"){throw new TypeError("GroupBy(); TypeError: callback is not a function");}if(keyCoercion!=="PROPERTY"&&keyCoercion!=="COLLECTION"){throw new Error("GroupBy(); Error: keyCoercion has to be \"PROPERTY\" or \"COLLECTION\"");}let k=0;let groups=[];for(let item of items){if(k>(Math.pow(2,53)-1)){throw new RangeError("GroupBy(); RangeError: iterator size")}let key=callback(item,k);if(keyCoercion==="PROPERTY"){key=(typeof key==="symbol"?key:String(key));}else{key=((1/key===-Infinity)?0:key);}AddValueToKeyedGroup(groups,key,item);k++;}return groups;}
function SetterThatIgnoresPrototypeProperties(thisValue,home,p,v){function CreateDataPropertyOrThrow(O,P,V){Object.defineProperty(O,P,{writable:true,enumerable:true,configurable:true,value:V});if(O[P]!==V){throw new Error("CreateDataPropertyOrThrow(); error: "+O+"["+P+"]" );}return O;}function Set(O,P,V,Throw=false){O[P]=V;if(O[P]!==V&& Throw){throw new TypeError("Set(); error: "+O+"["+P+"]");}}if((thisValue!=null&&typeof thisValue!=="object")){throw new TypeError("SetterThatIgnoresPrototypeProperties(); TypeError: thisValue is not an object");}if(Object.is(thisValue,home)){throw new TypeError("SetterThatIgnoresPrototypeProperties(); TypeError: Throwing here emulates assignment to a non-writable data property on the home object in strict mode code.");}let desc=thisValue[p];if(desc===undefined){CreateDataPropertyOrThrow(thisValue,p,v);}else{Set(thisValue,p,v,true);}}
const GetIteratorDirect=(O)=>({"[[Iterator]]":O,"[[NextMethod]]":O.next,"[[Done]]":false});
function GetIteratorFromMethod(O,method){let iterator=Reflect.apply(method,O,[]);if(((iterator===null)?"null":(typeof iterator))!=="object"){throw new TypeError();}return {"[[Iterator]]":iterator,"[[NextMethod]]":iterator.next,"[[Done]]":false};}
function GetIterator(O,kind){async function* createAsyncIterable(syncIterable){for(const item of syncIterable){yield item;}}let iterator;if(kind==="ASYNC"){if(O[Symbol.asyncIterator]===undefined&&O[Symbol.iterator]===undefined){throw new TypeError("GetIterator(); Error: "+O+" is not sync/async iterable");}if(O[Symbol.asyncIterator]!==undefined){iterator=O[Symbol.asyncIterator]();}if(O[Symbol.asyncIterator]===undefined&&O[Symbol.iterator]!==undefined){iterator=createAsyncIterable(O);}}else{if(O[Symbol.iterator]===undefined){throw new TypeError("GetIterator(); Error: "+O+" is not sync iterable");}iterator=O[Symbol.iterator]();}if(((iterator===null)?"null":(typeof iterator))!=="object"){throw new TypeError("GetIterator(); Error: iterator");}return {"[[Iterator]]":iterator,"[[NextMethod]]":iterator.next,"[[Done]]":false};}
function GetIteratorFlattenable(O,primitiveHandling){const Type=(O)=>(O===null?"null":typeof O);if(Type(O)!=="object"){if(primitiveHandling==="REJECT-PRIMITIVES"){throw new TypeError("GetIteratorFlattenable(); TypeError: "+O+" is not an object" );}if(primitiveHandling==="ITERATE-STRING-PRIMITIVES"&&typeof O!=="string"){throw new TypeError( "GetIteratorFlattenable(); TypeError: "+O+" is not a string");}}if(O[Symbol.iterator]===undefined){var iterator=O;}else{var iterator=O[Symbol.iterator]();}if(Type(iterator)!=="object"){throw new TypeError("GetIteratorFlattenable(); TypeError: "+iterator+" is not an object");}return {"[[Iterator]]":iterator,"[[NextMethod]]":iterator.next,"[[Done]]":false};}
function IteratorNext(iteratorRecord,value){const Type=(O)=>(O===null?"null":typeof O);if(Type(iteratorRecord)!=="object"){throw new TypeError("IteratorNext(); TypeError: iteratorRecord is not an object");}let result;if(value==null){result=Reflect.apply(iteratorRecord["[[NextMethod]]"],iteratorRecord["[[Iterator]]"],[]);}else{result=Reflect.apply(iteratorRecord["[[NextMethod]]"],iteratorRecord["[[Iterator]]"],[value]);}if(Type(result)!=="object"){iteratorRecord["[[Done]]"]=true;throw new TypeError("IteratorNext(); TypeError: result is not an object");}return result;}
const IteratorComplete=(iterResult)=>Boolean(iterResult["done"]);
const IteratorValue=(iterResult)=>iterResult["value"];
function IteratorStep(iteratorRecord){function IteratorNext(iteratorRecord,value){const Type=(O)=>(O===null?"null":typeof O);if(Type(iteratorRecord)!=="object"){throw new TypeError("IteratorNext(); TypeError: iteratorRecord is not an object" );}let result;if(value==null){result=Reflect.apply(iteratorRecord["[[NextMethod]]"],iteratorRecord["[[Iterator]]"],[]);}else{result=Reflect.apply(iteratorRecord["[[NextMethod]]"],iteratorRecord["[[Iterator]]"],[value]);}if(Type(result)!=="object"){iteratorRecord["[[Done]]"]=true;throw new TypeError("IteratorNext(); TypeError: result is not an object");}return result;}var result=IteratorNext(iteratorRecord);var done=Boolean(result["done"]);if(done){iteratorRecord["[[Done]]"]=true;return done;}return result;}
function IteratorStepValue(iteratorRecord){function IteratorStep(iteratorRecord){function IteratorNext(iteratorRecord,value){const Type=(O)=>(O===null?"null":typeof O);if(Type(iteratorRecord)!=="object"){throw new TypeError("IteratorNext(); TypeError: iteratorRecord is not an object");}let result;if(value==null){result=Reflect.apply(iteratorRecord["[[NextMethod]]"],iteratorRecord["[[Iterator]]"],[]);}else{result=Reflect.apply(iteratorRecord["[[NextMethod]]"],iteratorRecord["[[Iterator]]"],[value]);}if(Type(result)!=="object"){iteratorRecord["[[Done]]"]=true;throw new TypeError("IteratorNext(); TypeError: result is not an object");}return result; } var result=IteratorNext(iteratorRecord);var done=Boolean(result["done"]);if(done){iteratorRecord["[[Done]]"]=true;return done;}return result;}let result=IteratorStep(iteratorRecord);if(result===true){return true;}try{var value=result.value;}catch(e){iteratorRecord["[[Done]]"]=true;throw new TypeError("IteratorStepValue(); Error: "+e);}return value;}
function IteratorClose(iteratorRecord,completion){function GetMethod(O,P){let func=O[P];if(func==null){return undefined;}if(typeof func!=="function"){throw new TypeError("Method not callable: "+P);}return func;}function Completion(completionRecord){if(completionRecord!=null&&typeof completionRecord==="object"){let crKeys=Object.keys(completionRecord);if(crKeys.length===3&&crKeys.includes("[[Type]]")&&crKeys.includes("[[Value]]")&&crKeys.includes("[[Target]]")){return completionRecord;}}throw new TypeError("Completion(); TypeError: completionRecord is not a Completion Record" );}let iterator=iteratorRecord["[[Iterator]]"];if(iterator==null||typeof iterator!=="object"){throw new TypeError("IteratorClose(); TypeError: iterator have to be an object");}let innerReturn=GetMethod(iterator,"return");if(innerReturn===undefined){return Completion(completion);}let innerResult=Reflect.apply(innerReturn,iterator,[]);if(completion["[[Type]]"]==="THROW"){return completion;}if(innerResult["[[Type]]"]==="THROW"){return innerResult;}if(innerResult==null||typeof innerResult!=="object"){throw new TypeError("Completion(); TypeError: iterator return function return value is not an object");}return Completion(completion);}
const CreateIteratorResultObject=(v,done)=>({"value":v,"done":done});
function CreateListIteratorRecord (list){let obj=Array.from(list).values();return({"[[Iterator]]":obj,"[[NextMethod]]":obj.next,"[[Done]]":false});}
const IteratorToList=(iteratorRecord)=>[...iteratorRecord["[[Iterator]]"]];
function IfAbruptCloseIterator(value,iteratorRecord){function Completion(completionRecord){if(completionRecord!=null&& typeof completionRecord==="object"){let crKeys=Object.keys(completionRecord);if(crKeys.length===3&& crKeys.includes("[[Type]]")&&crKeys.includes("[[Value]]")&&crKeys.includes("[[Target]]")){return completionRecord;}}throw new TypeError("Completion(); TypeError: completionRecord is not a Completion Record");}function IteratorClose(iteratorRecord,completion){function GetMethod(O,P){let func=O[P];if(func==null){return undefined;}if(typeof func!=="function"){throw new TypeError("Method not callable: "+P);}return func;}function Completion(completionRecord){if(completionRecord!=null&& typeof completionRecord==="object"){let crKeys=Object.keys(completionRecord);if(crKeys.length===3&&crKeys.includes("[[Type]]")&&crKeys.includes("[[Value]]")&& crKeys.includes("[[Target]]")){return completionRecord;}}throw new TypeError("Completion(); TypeError: completionRecord is not a Completion Record");}let iterator=iteratorRecord["[[Iterator]]"];if(iterator==null||typeof iterator!=="object"){throw new TypeError("IteratorClose(); TypeError: iterator have to be an object");}let innerReturn=GetMethod(iterator,"return");if(innerReturn===undefined){return Completion(completion);}let innerResult=Reflect.apply(innerReturn,iterator,[]);if(completion["[[Type]]"]==="THROW"){return completion;}if(innerResult["[[Type]]"]==="THROW"){return innerResult;}if(innerResult==null||typeof innerResult!=="object"){throw new TypeError("Completion(); TypeError: iterator return function return value is not an object");}return Completion(completion);}Completion(value);if(value["[[Type]]"]!=="NORMAL"){return IteratorClose(iteratorRecord,value);}else{value=value;}}
function AsyncIteratorClose(iteratorRecord,completion){function GetMethod(O,P){let func=O[P];if(func==null){return undefined;}if(typeof func!=="function"){throw new TypeError("Method not callable: "+P);}return func;}function Completion(completionRecord){if(completionRecord!=null&&typeof completionRecord==="object"){let crKeys=Object.keys(completionRecord);if(crKeys.length===3&&crKeys.includes("[[Type]]")&&crKeys.includes("[[Value]]")&&crKeys.includes("[[Target]]")){return completionRecord;}}throw new TypeError("Completion(); TypeError: completionRecord is not a Completion Record" );}let iterator=iteratorRecord["[[Iterator]]"];if(iterator==null||typeof iterator!=="object"){throw new TypeError("AsyncIteratorClose(); TypeError: iterator have to be an object");}let innerReturn=GetMethod(iterator,"return");if(innerReturn===undefined){return Completion(completion);}let innerResult=Reflect.apply(innerReturn,iterator,[]);if(completion["[[Type]]"]==="THROW"){return completion;}if(innerResult["[[Type]]"]==="THROW"){return innerResult;}if(innerResult==null||typeof innerResult!=="object"){throw new TypeError("Completion(); TypeError: iterator return function return value is not an object");}return Completion(completion);}
/* ClearKeptObjects */
/* AddToKeptObjects */
/* CleanupFinalizationRegistry */
function CanBeHeldWeakly(v){if(v!=null&&typeof v==="object"){return true;}if(typeof v==="symbol"&&Symbol.keyFor(v)===undefined){return true;}return false;}
function OrdinaryObjectCreate(proto,additionalInternalSlotsList){if(additionalInternalSlotsList==null){additionalInternalSlotsList={};}let O={};if(additionalInternalSlotsList !=null&&typeof additionalInternalSlotsList==="object"){for(let key of Object.keys(additionalInternalSlotsList)){Object.defineProperty(O,key,{configurable:true,enumerable:false,writable:true,value:additionalInternalSlotsList[key]});}}Object.setPrototypeOf(O,proto);return O;}
function OrdinaryCreateFromConstructor(constructor,intrinsicDefaultProto,internalSlotsList){if(internalSlotsList==null){internalSlotsList={};}let proto=constructor["prototype"];if(proto==null&&typeof proto!=="object"){proto=intrinsicDefaultProto;}let res=Object.create(proto);for(let key of Object.keys(internalSlotsList)){Object.defineProperty(res,key,{configurable:true,enumerable:false,writable:true,value:internalSlotsList[key]});}return res;}
function GetPrototypeFromConstructor(constructor,intrinsicDefaultProto){let proto=constructor["prototype"];if(proto==null&&typeof proto!=="object"){proto=intrinsicDefaultProto;}return proto;}
function RequireInternalSlot(O,internalSlot){if(O==null||typeof O!=="object"){throw new TypeError("RequireInternalSlot(); TypeError: O is not an object");}if(!(internalSlot in O)){throw new TypeError("RequireInternalSlot(); TypeError: internalSlot not in O");}}
const OrdinaryFunctionCreate=(functionPrototype,sourceText,ParameterList,Body,thisMode,env,privateEnv)=>Function(...ParameterList,Body);
/* AddRestrictedFunctionProperties */
function MakeConstructor(F,writablePrototype,proto){const Type=(v)=>((v===null)?"null":(typeof v));function OrdinaryObjectCreate(proto){let O={};Object.setPrototypeOf(O,proto);return O;}if(Type(F)!=="function"){throw new TypeError("MakeConstructor();TypeError: F is not a function");}if(!Object.isExtensible(F)){throw new TypeError("MakeConstructor();TypeError: F is not extensible");}if(writablePrototype==null){writablePrototype=true;}if(proto==null){proto=OrdinaryObjectCreate(Object.prototype)||F.prototype;Object.defineProperty(proto,"constructor",{writable:writablePrototype,enumerable:false,configurable:true,value:F});}Object.defineProperty(F,"prototype",{writable:writablePrototype,enumerable:false,configurable:false,value:proto});}
/* MakeClassConstructor */
const MakeMethod=(F,homeObject)=>void(F.prototype=homeObject);
function DefineMethodProperty(homeObject,key,closure,enumerable){if(homeObject==null||typeof homeObject!=="object"||!Object.isExtensible(homeObject)){throw new TypeError("DefineMethodProperty(); TypeError: homeObject is not an extensible object");}Object.defineProperty(homeObject,key,{value:closure,writable:true,enumerable:enumerable,configurable:true});}
function SetFunctionName(F,name,prefix){if(typeof name==="symbol"){name="["+name.description+"]";}if(prefix!=null){name=prefix+" "+name;}Object.defineProperty(F,"name",{writable:false,enumerable:false,configurable:true,value:String(name)});}
function SetFunctionLength(F,length){if(!Object.isExtensible(F)||Object.hasOwn(F,length)){throw new TypeError ("SetFunctionLength(); TypeError: F is not extensible or has a length property");}else{Object.defineProperty(F,"length",{writable:false,enumerable:false,configurable:true,value:length});}}
/* FunctionDeclarationInstantiation */
/* BuiltinCallOrConstruct */
/* CreateBuiltinFunction */
/* BoundFunctionCreate */
function ArrayCreate(length=0,proto){length=Number(length);if(1/length===-Infinity){length=0;}if(length>(Math.pow(2,32)-1)){throw new RangeError("ArrayCreate(); Error: Invalid array length "+length);}if(proto==null||proto===Array.prototype){return Array(length);}var A={};Object.setPrototypeOf(A,proto);A.length=length;return A;}
function ArraySpeciesCreate(originalArray,length){function ArrayCreate(length=0,proto){length=Number(length);if(1/length===-Infinity){length=0;}if(length>(Math.pow(2,32)-1)){throw new RangeError("ArrayCreate(); Error: Invalid array length "+length);}if(proto==null||proto===Array.prototype){return Array(length);}var A={};Object.setPrototypeOf(A,proto);A.length=length;return A;}if(length===0&&1/length===-Infinity){length=0;}if(!Array.isArray(originalArray)){return ArrayCreate(length);}let C=originalArray.constructor;if(((C===null)?"null":(typeof C))==="object"){C="Symbol" in self&&"species" in self.Symbol?C[self.Symbol.species]:undefined;if(C===null){C=undefined;}}if(C===undefined){return ArrayCreate(length);}if(typeof C!=="function"||typeof C.prototype!=="object"){throw new TypeError("ArraySpeciesCreate(); Error: C must be a constructor");}return new C(length);}
function ArraySetLength(A,Desc){if(Desc.Value !=null){Desc=Desc.Value;}if(!Array.isArray(A)){throw new TypeError("A must be an Array");}if(!Number.isSafeInteger(Desc)||Desc<0||1/Desc===-Infinity){ throw new RangeError("Invalid array length");} A.length=Desc;return A.length===Desc;}
function StringCreate(v,Prototype){if(typeof v!=="string"){ throw new TypeError("StringCreate();error");}return v.slice();}
const StringGetOwnProperty=(S,P)=>S[P];
function CreateUnmappedArgumentsObject(){return arguments;}
/* CreateMappedArgumentsObject */
/* MakeTypedArrayWithBufferWitnessRecord */
const TypedArrayCreate=(proto)=>Reflect.construct(proto.constructor,[]);
function TypedArrayByteLength (taRecord){function TypedArrayElementSize(O){if(O instanceof Int8Array){return 1;}if(O instanceof Uint8Array){return 1;}if(O instanceof Uint8ClampedArray){return 1;}if(O instanceof Int16Array){return 2;}if(O instanceof Uint16Array){return 2;}if(O instanceof Int32Array){return 4;}if(O instanceof Uint32Array){return 4;}if(O instanceof BigInt64Array){return 8;}if(O instanceof BigUint64Array){return 8;}if("Float16Array" in window){if(O instanceof Float16Array){return 2;}}if(O instanceof Float32Array){return 4;}if(O instanceof Float64Array){return 8;}}return TypedArrayElementSize(taRecord["[[Object]]"])*taRecord["[[Object]]"].length;}
const TypedArrayLength=(taRecord)=>taRecord["[[Object]]"]["length"];
/* IsTypedArrayOutOfBounds */
/* IsTypedArrayFixedLength */
const IsValidIntegerIndex=(O,index)=>(typeof index==="number"&&Number.isInteger(index)&&1/index!==-Infinity&&index>-1&&index<O.length);
const TypedArrayGetElement=(O,index)=>O[index];
function TypedArraySetElement(O,index,value){let isValidIndex=(Number.isInteger(index)&&index>-1&&index<O.length);let newValue=(O instanceof BigUint64Array||O instanceof BigInt64Array)?BigInt(value):Number(value);if(isValidIndex){O[index]=newValue;}}
/* IsArrayBufferViewOutOfBounds */
/* ModuleNamespaceCreate */
const SetImmutablePrototype=(O,V)=>Object.is(Object.getPrototypeOf(O),V);
function ValidateNonRevokedProxy(proxy){if(proxy["[[ProxyTarget]]"]===null){throw new TypeError("ValidateNonRevokedProxy(); Error: ProxyTarget is null: ",proxy);}if(proxy["[[ProxyHandler]]"]===null){throw new TypeError("ValidateNonRevokedProxy(); Error: ProxyHandler is null: ",proxy);}}
const ProxyCreate=(target,handler)=>new Proxy(target,handler);
const UTF16EncodeCodePoint=(cp)=>String.fromCodePoint([cp]);
const CodePointsToString=(text)=>String.fromCodePoint(...text);
function UTF16SurrogatePairToCodePoint(lead,trail){let message="UTF16SurrogatePairToCodePoint();";if(typeof lead!=="number"){throw new TypeError(message+" TypeError: lead is not number");}if(typeof trail!=="number"){throw new TypeError(message+" TypeError: trail is not number");}try {return String.fromCodePoint(lead,trail);}catch(e){throw new RangeError(message+e);}}
const CodePointAt=(string,position)=>string.codePointAt(position);
const StringToCodePoints=(str)=>Array.from(str,(v)=>v.codePointAt(0));
/* ParseText(sourceText,goalSymbol) */
/* GetTemplateObject(templateLiteral) */
const KeyForSymbol=(sym)=>Symbol.keyFor(sym);
function InstallErrorCause(O,options){if(options !=null&&typeof options==="object"&&"cause" in options){Object.defineProperty(O,"cause",{writable:true,enumerable:false,configurable:true,value:options["cause"]});}}
function NumberToBigInt(v){if(typeof v!=="number"||!Number.isSafeInteger(v)){throw new RangeError("NumberToBigInt();RangeError: number is not an integer");}return v;}
function TrimString(string,where){if(string==null){throw new TypeError(Object.prototype.toString.call(argument)+ " is not coercible to Object.");}let str=String(string);if(where==="START"){return str.trimStart();}if(where==="END"){return str.trimEnd();}if(where==="START+END"){return str.trim();}}
function CreateArrayIterator(array,kind){if(kind==="KEY"){return array.keys();}if(kind==="VALUE"){return array.values();}if(kind==="KEY+VALUE"){return array.entries();}}
function FindViaPredicate(O,len,direction,predicate,thisArg){if(typeof predicate!=="function"){throw new TypeError("FindViaPredicate TypeError: predicate is not a function");}if(direction==="ascending"){let i=0;while(i<len){if(Boolean(predicate(O[i],i))){return({"index":i,"value":O[i]});}i++;}}else{let i=len;while(i>-1){if(Boolean(predicate(O[i],i))){return({"index":i,"value":O[i]});}i--;}}return({"index":-1,"value":undefined});}
function FlattenIntoArray(target,source,sourceLen,start,depth,mapperFunction,thisArg){function _FlattenIntoArray(target,source,sourceLen,start,depth,mapperFunction,thisArg){function ToLength(argument){let v=+argument;if(1/v===Infinity||1/v===-Infinity||v!==v){v=0;}let len=((v===Infinity||v===-Infinity)?v:Math.trunc(v));if(len<0){return 0;}return Math.min(len,Math.pow(2,53)-1);}let targetIndex=start;let sourceIndex=0;while(sourceIndex<sourceLen){let P=String(sourceIndex);if(P in source){let element=source[P];if(typeof mapperFunction==="function"&&!Array.isArray(element)){element=Reflect.apply(mapperFunction,thisArg,[element,sourceIndex,source]);}let shouldFlatten=false;if(depth>0){shouldFlatten=Array.isArray(element);}if(shouldFlatten){targetIndex=_FlattenIntoArray(target,element,ToLength(element.length),targetIndex,depth-1,mapperFunction);}else{if(targetIndex>=(Math.pow(2,53)-1)){throw new TypeError("targetIndex is greater than or equal to 2^53-1");}target[String(targetIndex)]=element;targetIndex++;}}sourceIndex++;}return targetIndex;}return _FlattenIntoArray(target,source,sourceLen,start,depth,mapperFunction,thisArg);}
function SortIndexedProperties(obj,len,SortCompare,holes){const Type=(O)=>(O===null?"null":typeof O);if(Type(obj)!=="object"){throw new TypeError("SortIndexedProperties(); TypeError: obj is not an object");}if(Type(SortCompare)!=="function"){throw new TypeError("SortIndexedProperties(); TypeError: SortCompare is not a function");}if(holes!=="SKIP-HOLES"&&holes!=="READ-THROUGH-HOLES"){throw new Error("SortIndexedProperties(); Error: holes has to be \"SKIP-HOLES\" or \"READ-THROUGH-HOLES\"");}let items=[];let k=0;while(k<len){let pK=String(k);if(holes==="SKIP-HOLES"){var kRead=pK in obj;}else{var kRead=true;}if(kRead){items.push(obj[pK]);}k++;}items.sort(SortCompare);return items;}
function CompareArrayElements(x,y,comparator){if(x===undefined&&y===undefined){return 0;}if(x===undefined){return 1;}if(y===undefined){return 0;}if(comparator!==undefined){let v=Number(comparator(x,y));if(v!==v){return 0;}return v;}let xString=String(x);let yString=String(y);if(xString<yString){return -1;}if(yString<xString){return 1;}return 0;}
const TypedArrayCreateFromConstructor=(constructor,argumentList)=>Reflect.construct(constructor,argumentList);
const TypedArraySpeciesCreate=(exemplar,argumentList)=>Reflect.construct(Object.getPrototypeOf(exemplar).constructor,argumentList);
const TypedArrayCreateSameType=(exemplar,argumentList)=>Reflect.construct(Object.getPrototypeOf(exemplar).constructor,argumentList);
const ValidateTypedArray=(O,order)=>(O instanceof Int8Array||O instanceof Uint8Array||O instanceof Uint8ClampedArray||O instanceof Int16Array||O instanceof Uint16Array||O instanceof Int32Array||O instanceof Uint32Array||("Float16Array" in window?O instanceof Float16Array:false)||O instanceof Float32Array||O instanceof Float64Array||O instanceof BigInt64Array||O instanceof BigUint64Array);
function TypedArrayElementSize(O){if(O instanceof Int8Array){return 1;}if(O instanceof Uint8Array){return 1;}if(O instanceof Uint8ClampedArray){return 1;}if(O instanceof Int16Array){return 2;}if(O instanceof Uint16Array){return 2;}if(O instanceof Int32Array){return 4;}if(O instanceof Uint32Array){return 4;}if(O instanceof BigInt64Array){return 8;}if(O instanceof BigUint64Array){return 8;}if("Float16Array" in window){if(O instanceof Float16Array){return 2;}}if(O instanceof Float32Array){return 4;}if(O instanceof Float64Array){return 8;}}
function TypedArrayElementType(O){if(O instanceof Int8Array){return "INT8";}if(O instanceof Uint8Array){return "UINT8";}if(O instanceof Uint8ClampedArray){return "UINT8CLAMPED";}if(O instanceof Int16Array){return "INT16";}if(O instanceof Uint16Array){return "UINT16";}if(O instanceof Int32Array){return "INT32";}if(O instanceof Uint32Array){return "UINT32";}if(O instanceof BigInt64Array){return "BIGINT64";}if(O instanceof BigUint64Array){return "BIGUINT64";}if("Float16Array" in window){if(O instanceof Float16Array){return "FLOAT16";}}if(O instanceof Float32Array){return "FLOAT32";}if(O instanceof Float64Array){return "FLOAT64";}}
function AddEntriesFromIterable(target,iterable,adder){for(let item of iterable){Reflect.apply(adder,target,item);}}
function CompareTypedArrayElements(x,y,comparator){const SameValue=Object.is||((x,y)=>((x===y)?(x!==0||1/x===1/y):(x!==x&&y!==y)));function Call(F,V,argumentsList=[]){if(!Array.isArray(argumentsList)){throw new TypeError("argumentsList should be an array: ",argumentsList);}return Function.prototype.apply.call(F,V,argumentsList);}let tx=typeof x,ty=typeof y;if(!((tx==="number"&&ty==="number")||(tx==="bigint"&&ty=="bigint"))){throw new TypeError("x and y have to be same type: BigInt or a Number");}if(typeof compareFn!=="function"&&typeof compareFn!=="undefined"){throw new TypeError("compareFN has to be a function or undefined");}if(typeof compareFn!=="undefined"){let v=+(Call(compareFn,undefined,[x,y]));if(v!==v){return 0;}return v;}if(x!==x&&y!==y){return 0;}if(x!==x){return 1;}if(y!==y){return -1;}if(x<y){return -1;}if(x>y){return 1;}if(SameValue(x,-0)&&SameValue(y,0)){return -1;}if(SameValue(x,0)&&SameValue(y,-0)){return 1;}return 0;}
function CreateMapIterator(map,kind){if(kind==="KEY"){return map.keys();}if(kind==="VALUE"){return map.values();}if(kind==="KEY+VALUE"){return map.entries();}}
function GetSetRecord(obj){function ToIntegerOrInfinity(argument){let v=Math.trunc(+argument);return (v!==v||v===0)?0:v;}function GetMethod(O,P){let func=O[P];if(func==null){return undefined;}if(typeof func!=="function"){throw new TypeError("Method not callable: "+P);}return func;}if((obj==null||typeof obj!=="object")){throw new TypeError( "GetSetRecord(); TypeError: obj is not an object");}let numSize=+obj["size"];if(numSize!==numSize){throw new TypeError("GetSetRecord(); TypeError: numSize is NaN");}let intSize=ToIntegerOrInfinity(numSize);if(intSize<0){throw new TypeError("GetSetRecord(); TypeError: intSize is less then 0");}return {"[[SetObject]]":obj,"[[Size]]":intSize,"[[Has]]":GetMethod(obj,"has"),"[[Keys]]":GetMethod(obj,"keys")};}
function SetDataHas(setData,value){let i=0;for(let item of setData){if(item!=null&&(item===value||(item!==item&&value!==value))){return true;}i++;}return false;}
function SetDataIndex(setData,value){let i=0;for(let item of setData){if(item!=null&&(item===value||(item!==item&&value!==value))){return i;}i++;}return "NOT-FOUND";}
function CreateSetIterator(seto,kind){if(kind==="KEY"){return seto.keys();}if(kind==="VALUE"){return seto.values();}if(kind==="KEY+VALUE"){return seto.entries();}}
function SetDataSize(setData){let i=0;for(let item of setData){if(item!=null){i++;}}return i;}
const CanonicalizeKeyedCollectionKey=(key)=>((1/key===-Infinity)?0:key);
const WeakRefDeref=(weakRef)=>void(weakRef.deref());
function CreateAsyncFromSyncIterator(syncIteratorRecord){async function* createAsyncIterable(syncIterable){for(let item of syncIterable){yield item;}}let asyncIterator=createAsyncIterable(syncIteratorRecord["[[Iterator]]"]);return {"[[Iterator]]":asyncIterator,"[[NextMethod]]":asyncIterator.next,"[[Done]]":false};}
/* AsyncFromSyncIteratorContinuation */
/* CreateResolvingFunctions */
/* FulfillPromise */
/* NewPromiseCapability */
const IsPromise=(x)=>(x instanceof Promise||(x!=null&&typeof x==="object"&& typeof x.then==="function"&&typeof x.catch==="function"));
/* RejectPromise */
/* TriggerPromiseReactions */
/* HostPromiseRejectionTracker */
function CreateHTML(string,tag,attribute,value){if(typeof string!=="string"){throw new TypeError(Object.prototype.toString.call(string)+ " has a to be a String.");}let S=String(string);let res="<"+tag;if(attribute !=null&&attribute!==""){let V=String(value).replace(/\x22/g,"&quot;"); res +=" "+attribute+"=\""+V+"\"";}return res+">"+S+"</"+tag+">";}
/** object header **/
const VERSION="Zephyr v1.0.1 esm";
function noConflict(){window.ES=zephyr.__prevES__;return zephyr;}
const IsObject=(x)=>(x!=null&&typeof x==="object");
const zephyr={/** object header **/ VERSION, noConflict, IsObject, /** API **/ Completion, Type, StringIndexOf, StringLastIndexOf, NormalCompletion, ThrowCompletion, ReturnCompletion, UpdateEmpty, /* IsAccessorDescriptor, *//* IsDataDescriptor, *//* IsGenericDescriptor, *//* FromPropertyDescriptor, *//* ToPropertyDescriptor, *//* CompletePropertyDescriptor, */ ToPrimitive, OrdinaryToPrimitive, ToBoolean, ToNumeric, ToNumber, StringToNumber, ToIntegerOrInfinity, ToInt32, ToUint32, ToInt16, ToUint16, ToInt8, ToUint8, ToUint8Clamp, ToBigInt, StringToBigInt, ToBigInt64, ToBigUint64, ToString, ToObject, ToPropertyKey, ToLength, CanonicalNumericIndexString, RequireObjectCoercible, ToIndex, IsArray, IsCallable, IsConstructor, IsExtensible, IsIntegralNumber, IsRegExp, IsPropertyKey, IsStringWellFormedUnicode, SameType, SameValue, SameValueZero, SameValueNonNumber, IsLessThan, IsLooselyEqual, IsStrictlyEqual, MakeBasicObject, Get, GetV, Set, CreateDataProperty, CreateDataPropertyOrThrow, CreateNonEnumerableDataPropertyOrThrow, DefinePropertyOrThrow, DeletePropertyOrThrow, GetMethod, HasProperty, HasOwnProperty, Call, Construct, SetIntegrityLevel, TestIntegrityLevel, CreateArrayFromList, LengthOfArrayLike, CreateListFromArrayLike, Invoke, OrdinaryHasInstance, SpeciesConstructor, EnumerableOwnProperties, /* GetFunctionRealm, */ CopyDataProperties, /* PrivateElementFind, *//* PrivateFieldAdd, *//* PrivateMethodOrAccessorAdd, *//* PrivateGet, *//* PrivateSet, *//* DefineField, *//* InitializeInstanceElements, */ AddValueToKeyedGroup, GroupBy, SetterThatIgnoresPrototypeProperties, GetIteratorDirect, GetIteratorFromMethod, GetIterator, GetIteratorFlattenable, IteratorNext, IteratorComplete, IteratorValue, IteratorStep, IteratorStepValue, IteratorClose, IfAbruptCloseIterator, AsyncIteratorClose, CreateIteratorResultObject, CreateListIteratorRecord, IteratorToList, /* AddToKeptObjects, */ /* ClearKeptObjects, */ /* CleanupFinalizationRegistry,*/ CanBeHeldWeakly, OrdinaryObjectCreate, OrdinaryCreateFromConstructor, GetPrototypeFromConstructor, RequireInternalSlot, OrdinaryFunctionCreate, /* AddRestrictedFunctionProperties, */ MakeConstructor, /* MakeClassConstructor, */ MakeMethod, DefineMethodProperty, SetFunctionName, SetFunctionLength, /* FunctionDeclarationInstantiation, *//* BuiltinCallOrConstruct, *//* CreateBuiltinFunction, *//* BoundFunctionCreate, */ ArrayCreate, ArraySpeciesCreate, ArraySetLength, StringCreate, StringGetOwnProperty, CreateUnmappedArgumentsObject, /* CreateMappedArgumentsObject, *//* MakeTypedArrayWithBufferWitnessRecord, */ TypedArrayCreate, TypedArrayByteLength, TypedArrayLength, /* IsTypedArrayOutOfBounds, *//* IsTypedArrayFixedLength, */ IsValidIntegerIndex, TypedArrayGetElement, TypedArraySetElement, /* IsArrayBufferViewOutOfBounds, *//* ModuleNamespaceCreate, */ SetImmutablePrototype, ValidateNonRevokedProxy, ProxyCreate, UTF16EncodeCodePoint, CodePointsToString, UTF16SurrogatePairToCodePoint, CodePointAt, StringToCodePoints, /* ParseText, *//* GetTemplateObject, */ KeyForSymbol, InstallErrorCause, NumberToBigInt, TrimString, CreateArrayIterator, FindViaPredicate, FlattenIntoArray, SortIndexedProperties, CompareArrayElements, TypedArrayCreateFromConstructor, TypedArraySpeciesCreate, TypedArrayCreateSameType, ValidateTypedArray, TypedArrayElementSize, TypedArrayElementType, AddEntriesFromIterable, CompareTypedArrayElements, CreateMapIterator, GetSetRecord, SetDataHas, SetDataIndex, SetDataSize, CreateSetIterator, CanonicalizeKeyedCollectionKey, WeakRefDeref, CreateAsyncFromSyncIterator, /* AsyncFromSyncIteratorContinuation, */ /* CreateResolvingFunctions, */ /* FulfillPromise, */ /* NewPromiseCapability, */ IsPromise, /* RejectPromise, */ /* TriggerPromiseReactions, */ /* HostPromiseRejectionTracker, */ CreateHTML};
if(typeof window!=="undefined"){zephyr.__prevES__=window.ES;window.zephyr=zephyr;window.ES=zephyr;}
/* ESM */
export default zephyr;
export {/** object header **/ VERSION, noConflict, IsObject, /** API **/ Completion, Type, StringIndexOf, StringLastIndexOf, NormalCompletion, ThrowCompletion, ReturnCompletion, UpdateEmpty, /* IsAccessorDescriptor, *//* IsDataDescriptor, *//* IsGenericDescriptor, *//* FromPropertyDescriptor, *//* ToPropertyDescriptor, *//* CompletePropertyDescriptor, */ ToPrimitive, OrdinaryToPrimitive, ToBoolean, ToNumeric, ToNumber, StringToNumber, ToIntegerOrInfinity, ToInt32, ToUint32, ToInt16, ToUint16, ToInt8, ToUint8, ToUint8Clamp, ToBigInt, StringToBigInt, ToBigInt64, ToBigUint64, ToString, ToObject, ToPropertyKey, ToLength, CanonicalNumericIndexString, RequireObjectCoercible, ToIndex, IsArray, IsCallable, IsConstructor, IsExtensible, IsIntegralNumber, IsRegExp, IsPropertyKey, IsStringWellFormedUnicode, SameType, SameValue, SameValueZero, SameValueNonNumber, IsLessThan, IsLooselyEqual, IsStrictlyEqual, MakeBasicObject, Get, GetV, Set, CreateDataProperty, CreateDataPropertyOrThrow, CreateNonEnumerableDataPropertyOrThrow, DefinePropertyOrThrow, DeletePropertyOrThrow, GetMethod, HasProperty, HasOwnProperty, Call, Construct, SetIntegrityLevel, TestIntegrityLevel, CreateArrayFromList, LengthOfArrayLike, CreateListFromArrayLike, Invoke, OrdinaryHasInstance, SpeciesConstructor, EnumerableOwnProperties, /* GetFunctionRealm, */ CopyDataProperties, /* PrivateElementFind, *//* PrivateFieldAdd, *//* PrivateMethodOrAccessorAdd, *//* PrivateGet, *//* PrivateSet, *//* DefineField, *//* InitializeInstanceElements, */ AddValueToKeyedGroup, GroupBy, SetterThatIgnoresPrototypeProperties, GetIteratorDirect, GetIteratorFromMethod, GetIterator, GetIteratorFlattenable, IteratorNext, IteratorComplete, IteratorValue, IteratorStep, IteratorStepValue, IteratorClose, IfAbruptCloseIterator, AsyncIteratorClose, CreateIteratorResultObject, CreateListIteratorRecord, IteratorToList, /* AddToKeptObjects, */ /* ClearKeptObjects, */ /* CleanupFinalizationRegistry,*/ CanBeHeldWeakly, OrdinaryObjectCreate, OrdinaryCreateFromConstructor, GetPrototypeFromConstructor, RequireInternalSlot, OrdinaryFunctionCreate, /* AddRestrictedFunctionProperties, */ MakeConstructor, /* MakeClassConstructor, */ MakeMethod, DefineMethodProperty, SetFunctionName, SetFunctionLength, /* FunctionDeclarationInstantiation, *//* BuiltinCallOrConstruct, *//* CreateBuiltinFunction, *//* BoundFunctionCreate, */ ArrayCreate, ArraySpeciesCreate, ArraySetLength, StringCreate, StringGetOwnProperty, CreateUnmappedArgumentsObject, /* CreateMappedArgumentsObject, *//* MakeTypedArrayWithBufferWitnessRecord, */ TypedArrayCreate, TypedArrayByteLength, TypedArrayLength, /* IsTypedArrayOutOfBounds, *//* IsTypedArrayFixedLength, */ IsValidIntegerIndex, TypedArrayGetElement, TypedArraySetElement, /* IsArrayBufferViewOutOfBounds, *//* ModuleNamespaceCreate, */ SetImmutablePrototype, ValidateNonRevokedProxy, ProxyCreate, UTF16EncodeCodePoint, CodePointsToString, UTF16SurrogatePairToCodePoint, CodePointAt, StringToCodePoints, /* ParseText, *//* GetTemplateObject, */ KeyForSymbol, InstallErrorCause, NumberToBigInt, TrimString, CreateArrayIterator, FindViaPredicate, FlattenIntoArray, SortIndexedProperties, CompareArrayElements, TypedArrayCreateFromConstructor, TypedArraySpeciesCreate, TypedArrayCreateSameType, ValidateTypedArray, TypedArrayElementSize, TypedArrayElementType, AddEntriesFromIterable, CompareTypedArrayElements, CreateMapIterator, GetSetRecord, SetDataHas, SetDataIndex, SetDataSize, CreateSetIterator, CanonicalizeKeyedCollectionKey, WeakRefDeref, CreateAsyncFromSyncIterator, /* AsyncFromSyncIteratorContinuation, */ /* CreateResolvingFunctions, */ /* FulfillPromise, */ /* NewPromiseCapability, */ IsPromise, /* RejectPromise, */ /* TriggerPromiseReactions, */ /* HostPromiseRejectionTracker, */ CreateHTML};
if(typeof window!=="undefined"){zephyr.__prevES__=window.ES;window.zephyr=zephyr;window.ES=zephyr;}
